using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Midi;
using System.IO;
using System.Threading;

namespace noteseq
{
	class ChannelPlayState
	{
		public int Index { get; set; }
		public string[] Channel { get; set; }
		public int SequenceIndex { get; set; }
		public int NoteIndex { get; set; }
		public int WaitTime { get; set; }
		public Note CurrentNote { get; set; }
		public bool Finished { get; set; }

		public ChannelPlayState(int index, string[] channel)
		{
			Index = index;
			Channel = channel;
		}
	}

	class Program
	{
		private static OutputDevice zeOutput;

		private static TrackLibrary mTrackLibrary;

		private static void Main(string[] args)
		{
			if (args.Length == 0) {
				WriteUsage();
				return;
			}

			string input_filename = args[0];
			string output_filename = Path.ChangeExtension(input_filename, ".s");

			if (!ParseNotes(input_filename))
				return;
			string output = GetNotesAssembly();
			File.WriteAllText(output_filename, output);

			PlayTrack(5);
		}

		private static void WriteUsage()
		{
			Console.WriteLine("noteseq.exe <filename>");
		}

		private static bool ParseNotes(string path)
		{
			NoteSeqParser parser = new NoteSeqParser();
			if (!parser.Read(path)) {
				Console.WriteLine(parser.Error);
				Console.ReadLine();
				return false;
			} else {
				mTrackLibrary = parser.TrackLibrary;
				return true;
			}
		}

		private static string GetNotesAssembly()
		{
			StringBuilder sb = new StringBuilder();

			sb.AppendFormat(";{0}\n", new String('-', 79));
			sb.AppendFormat("; Generated by noteseq at {0}\n", DateTime.Now);
			sb.AppendFormat(";{0}\n", new String('-', 79));

			sb.AppendFormat("tl_track_count\n  DEFW {0}\n", mTrackLibrary.Tracks.Length);
			sb.AppendFormat("tl_seq_count\n  DEFW {0}\n", mTrackLibrary.NoteSequences.Length);
			sb.AppendLine();

			sb.AppendFormat(";{0}\n", new String('-', 79));
			sb.AppendLine("tl_tracks");
			for (int i = 0; i < mTrackLibrary.Tracks.Length; i++)
				sb.AppendFormat("  DEFW tl_track_{0:00}\n", i);

			sb.AppendFormat(";{0}\n", new String('-', 79));
			sb.AppendLine("tl_seq");
			for (int i = 0; i < mTrackLibrary.NoteSequences.Length; i++)
				sb.AppendFormat("  DEFW tl_seq_{0:0000}\n", i);

			int tracknum = 0;
			foreach (Track track in mTrackLibrary.Tracks) {
				sb.AppendFormat(";{0}\n", new String('-', 79));
				sb.AppendFormat("tl_track_{0:00}\n", tracknum);
				sb.AppendFormat("  DEFB \"{0}\", 0\n", track.Name.Replace("\\", "\\\\").Replace("\"", "\\\""));
				sb.AppendFormat("  ALIGN\n");
				sb.AppendFormat("  DEFW {0}\n", track.BPM);
				sb.AppendFormat("  DEFW {0}\n", track.Channels.Count);
				foreach (string[] channel in track.Channels) {
					sb.AppendFormat("  DEFW ");
					foreach (string seqkey in channel)
						sb.AppendFormat("{0}, ", mTrackLibrary.GetNoteSequenceIndex(seqkey));
					sb.AppendFormat("-1\n");
				}
				tracknum++;
			}
			sb.AppendLine();

			int noteseqnum = 0;
			foreach (Note[] noteseq in mTrackLibrary.NoteSequences) {
				sb.AppendFormat(";{0}\n", new String('-', 79));
				sb.AppendFormat("tl_seq_{0:0000}\n", noteseqnum);

				if (noteseq.Length > 0) {
					int groupCount = 0;
					sb.AppendFormat("  DEFW ");
					List<Note> collection = new List<Note>(noteseq);
					collection.Add(Note.Empty);
					foreach (Note note in collection) {
						sb.AppendFormat("&{0:X8}, ", note.WordValue);
						groupCount++;
						if (groupCount >= 6) {
							sb.Remove(sb.Length - 2, 2);
							sb.AppendLine();
							sb.AppendFormat("  DEFW ");
							groupCount = 0;
						}
					}
					if (groupCount == 0) {
						sb.Remove(sb.Length - 7, 7);
					} else {
						sb.Remove(sb.Length - 2, 2);
						sb.AppendLine();
					}
				}

				noteseqnum++;
			}
			sb.AppendFormat(";{0}\n", new String('-', 79));

			return sb.ToString();
		}

		private static void PlayTrack(int trackIndex)
		{
			if (zeOutput == null) {
				zeOutput = OutputDevice.InstalledDevices[0];
				zeOutput.Open();
				/*
				zeOutput.SendProgramChange(Channel.Channel1, Instrument.Lead1Square);
				zeOutput.SendProgramChange(Channel.Channel2, Instrument.Lead1Square);
				*/
			}

			Track track = mTrackLibrary.Tracks[trackIndex];
			ChannelPlayState[] playState = new ChannelPlayState[track.Channels.Count];
			for (int i = 0; i < playState.Length; i++)
				playState[i] = new ChannelPlayState(i, track.Channels[i]);
			mBPM = track.BPM;
			mBarLength = 0.0;

			Console.WriteLine("Playing {0} at {1} bpm", track.Name, track.BPM);

			int lastTick = Environment.TickCount;
			while (!playState.All(x => x.Finished)) {
				int elapsedms = Environment.TickCount - lastTick;
				lastTick = Environment.TickCount;
				Array.ForEach(playState, x => x.WaitTime -= elapsedms);
				Array.ForEach(playState, x => PlayNextNote(x));
			}

			System.Threading.Thread.Sleep(1000);
		}

		private static int mBPM;
		private static double mBarLength;
		private static void PlayNextNote(ChannelPlayState playState)
		{
			if (playState.WaitTime > 0)
				return;

			zeOutput.SendNoteOff(Channel.Channel1 + playState.Index, NoteToPitch(playState.CurrentNote), 127);
			if (playState.Finished)
				return;

			int noteseqindex = mTrackLibrary.GetNoteSequenceIndex(playState.Channel[playState.SequenceIndex]);
			Note[] noteseq = mTrackLibrary.NoteSequences[noteseqindex];
			Note note = noteseq[playState.NoteIndex];

			if (playState.NoteIndex == 0 && playState.Index == 0) {
				if (mBarLength != 0.0)
					Console.WriteLine();
				Console.WriteLine("{0}:", mTrackLibrary.GetNoteSequenceKey(noteseqindex));
			}

			if (note.Key == Key.Rest) {
				if (playState.Index == 0)
					Console.Write("~   ");
			} else {
				if (playState.Index == 0)
					Console.Write("{0,2}{1} ", Note.GetStringFromKey(note.Key), note.Octave);
				zeOutput.SendNoteOn(Channel.Channel1 + playState.Index, NoteToPitch(note), 127);
			}
			playState.WaitTime = GetNoteTime(mBPM, note);
			playState.CurrentNote = note;

			playState.NoteIndex++;
			if (playState.NoteIndex >= noteseq.Length) {
				playState.SequenceIndex++;
				playState.NoteIndex = 0;
				if (playState.SequenceIndex >= playState.Channel.Length)
					playState.Finished = true;
			}

			if (playState.Index == 0) {
				mBarLength += note.BarLength;
				if (mBarLength >= 1.0) {
					Console.WriteLine();
					mBarLength = 0.0;
				}
			}
		}

		public static int GetNoteTime(int bpm, Note note)
		{
			double barLength = note.Bars + (note.BarFractions / 256.0);
			double beatLength = barLength * 4;
			int result = (int)((beatLength / bpm) * 60.0 * 1000.0);
			return result;
		}

		public static Pitch NoteToPitch(Note note)
		{
			return (Pitch)((int)Pitch.C0 + ((int)Pitch.C0 * note.Octave) + (int)note.Key - 1);
		}
	}
}
